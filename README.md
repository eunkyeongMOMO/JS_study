# JS_study

## vanillaJS 
모던 자바스크립트 DEEP Dive 책 정리

## DOM과 Virtual DOM
DOM(document object model)
웹페이지나 웹앱에 있는 html요소들을 구조적으로 표현한 것

DOM은 애플리케이션의 전체UI를 나타내며 데이터 구조로 표현된다. script를 통해 콘텐츠를 수정하고 이벤트를 추가할수있기때문에 매우 유용하다. 또한 구조화된 형식으로 되어 있어서 특정 노드를 선택할수 있다.

DOM 문제점?
 1. 노드가 많아질수록 속도가 느려지고 DOM업데이트에 잦은 오류를 발생시킬수 있다.
 2. 최근 모던 웹은 SPA을 사용하는데, 여러 동적인 기능이 들어가기 때문에 안그래도 리소스가 모두 합쳐진 무거운 HTML 문서를 지속적으로 재랜더링 해줘야함.
 
 Virtual DOM
 DOM을 가볍게 만든 script 표현이라고 할 수 있고 주로 React, vue에 사용된다. 가상 DOM은 실제로 스크린데 랜더링 하는것이 아니기때문에 DOM을 직접 업데이트 하는것보다 상대적으로 빠르다.
 
 가상DOM은 실제 DOM에ㅔ서 처리하는 방식이 아닌 Virtual DOM과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화 하는 프로게이밍 개념.
 
 | DOM | Virtual DOM
--|--|--
업데이트 | 느리다 | 빠르다
HTML업데이트 방식 | 새로운  element가 업데이트된 경우 새로운 DOM생성| 새로운element가 업데이트 된 경우 새로운 가상 DOM 생성 후 이전 DOM과 비교 후 차이나는 DOM만 업데이트
메모리 | 메모리 낭비가 심함 | 메모리 낭비가 덜함


### 변수

**변수 선언**
> 변수를 생성하는 것을 일컷는다. 값을 저장하기 위한 메모리 공간을 확보하고 변수명과 메모리공간의 주소를 연결해서 값을 저장할 수 있게 준비하는것. 
> 변수를 사용하려면 반드시 선언이 필요하며, 선언시 var, let, const 키워드를 사용한다. 
>> var를 이용하여 선언할 경우 초기화 단계에서 아무런 값을 할당하지 않으면 unfined값이 할당된다.

**변수 호이스팅**
>변수선언 런타임(소스코드가 한줄씩 실행되는 시점)이 아니라 그 이전 단계, 소스코드 평가 과정에서 
>자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행 시킨다. 선언문 소스코드 실행 이후 선언문을 제외한 소스코드를 한줄씩 순차적으로 실행한다.
>이 처럼 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.

**값 할당**

>변수에 값을 할당(대입, 저장) 할 때는 할당연산자[대입연산자] '='를 사용한다. 할당연산자는 우변의 값을 좌변의 변수에 할당한다.
>>*주의점*
>>변수 선언의 경우 호이스팅되어 런타임 이전에 선언되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
>>변수선언과 값의 할당을 각각 나누어 실행한다. 따라서 변수선언시 초기값으로 undfined가 할당되었던 것은 변함이 없다.

**값의 재할당**

> 재할당? 변수에 새로운 값을 할당하는것, [var, let 키워드로 생성된 변수만 재할당이 가능하다.]
> 변수에 값을 재할당 하면, 변수는 새로운 값으로 변경된다. 하지만 이전 값이 들어있는 메모리 공간을 지우고 새로 할당한 값을 저장하는것이 아닌 새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당 된 값을 저장한다.
>> 재할당 할수없어 변수의 값이 변경될 수 없다면 변수가 아니라 상수라 한다. 상수는 한번 정해지면 변하지 않는값을 의미한다.[const 키워드를 이용해 선언한 변수는 상수로, 추후 재할당이 불가하다.]

*가비지 콜렉터*
? 변수에 값이 재할당되어 더이상 사용하지 않는 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해체된다. 단 메모리에서 언제 해체될지는 예측할수 없다.
>>가비지 콜렉터는 애플리케이션이 할당한 ㅁ








### 객체와 배열

**Destructuring**

객체에안에 있는 필드 값을 원하는 변수에 대입 할 수 있다.  

```js
const sandwich={
bread :'더치 크런치',
meat:'참치',
cheese: '스위스',
topping:['상추','토마토','스위트어니언']
}
let {bread, meat} = sandwich;

console.log(bread,meat) //더치크런치 참지
```
위 코드는 객체를 분해하여 필드를 같은 이름의 변수에 넣어준다. 
**두변수의 값은 객체에 있는 필드값으로 초기화되지만, 두변수의 값을 재 할당해도 원래의 필드값은 변경되지 않는다.**

객체를 분해하여 함수의 인자로 넘길수도 있다. 

```js
const userName = (regularName) =>{
  console.log(` 유저 이름은! ${regularName.firstName}`)
}

let regularName ={
  firstName ='은경'
  lastName='잉'
}
userName(regularName); // 유저이름은! 은경

```

 객체 필드에 접근하기 위해 .과 필드명을 사용하는 대신에 객체에서 필요한 값을 구조분해로 가져올수 있다
 
 ```js
const userName = ({firstName}) =>{
  console.log(` 유저 이름은! ${regularName.firstName}`)
}

let regularName ={
  firstName ='은경'
  lastName='잉'
}
userName(regularName); // 유저이름은! 은경

```

배열의 구조 분해하기
>배열을 구조분해해서 값을 뽑아낼수도 있다. 

```js
const [pet1,pet2,pet3] = ['심바','모모','나나']

console.log(pet1) //'심바'
```


**객체 리터럴 개선**

>구조분해의 반대되는 개념이라고 할수 있다. 객체 리터럴개선을 사용하면 현재 영역에 변수를 객체의 필드로 묶을수 있다.


```js

const name = '은경';
const age = 33;

const userInfo = {name, age}

console.log(userInfo);// {name :'은경', age: 33}

```

**스프레드 연산자**

1. 스프레드 연산자를 사용해 배열의 내용을 조합할 수 있다. 예를 들어 두배열이 있다면 두 배열의 모두 들어간 새로운 배열을 만들수 있다.

```js
let array = [1,2,3];
let array02 = [4,5,6];
let newArray =[...array,...array02];

console.log(newArray) // [1,2,3,4,5,6]
```






## React

## TypeScript

## Task

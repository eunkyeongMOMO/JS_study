# JS_study

## vanillaJS 
모던 자바스크립트 DEEP Dive 책 정리

###변수

**변수 선언**
> 변수를 생성하는 것을 일컷는다. 값을 저장하기 위한 메모리 공간을 확보하고 변수명과 메모리공간의 주소를 연결해서 값을 저장할 수 있게 준비하는것. 
> 변수를 사용하려면 반드시 선언이 필요하며, 선언시 var, let, const 키워드를 사용한다. 
>> var를 이용하여 선언할 경우 초기화 단계에서 아무런 값을 할당하지 않으면 unfined값이 할당된다.

**변수 호이스팅**
>변수선언 런타임(소스코드가 한줄씩 실행되는 시점)이 아니라 그 이전 단계, 소스코드 평가 과정에서 
>자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행 시킨다. 선언문 소스코드 실행 이후 선언문을 제외한 소스코드를 한줄씩 순차적으로 실행한다.
>이 처럼 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.

**값 할당**

>변수에 값을 할당(대입, 저장) 할 때는 할당연산자[대입연산자] '='를 사용한다. 할당연산자는 우변의 값을 좌변의 변수에 할당한다.
>>*주의점*
>>변수 선언의 경우 호이스팅되어 런타임 이전에 선언되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
>>변수선언과 값의 할당을 각각 나누어 실행한다. 따라서 변수선언시 초기값으로 undfined가 할당되었던 것은 변함이 없다.

**값의 재할당**

> 재할당? 변수에 새로운 값을 할당하는것, [var, let 키워드로 생성된 변수만 재할당이 가능하다.]
> 변수에 값을 재할당 하면, 변수는 새로운 값으로 변경된다. 하지만 이전 값이 들어있는 메모리 공간을 지우고 새로 할당한 값을 저장하는것이 아닌 새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당 된 값을 저장한다.
>> 재할당 할수없어 변수의 값이 변경될 수 없다면 변수가 아니라 상수라 한다. 상수는 한번 정해지면 변하지 않는값을 의미한다.[const 키워드를 이용해 선언한 변수는 상수로, 추후 재할당이 불가하다.]

*가비지 콜렉터*
? 변수에 값이 재할당되어 더이상 사용하지 않는 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해체된다. 단 메모리에서 언제 해체될지는 예측할수 없다.
>>가비지 콜렉터는 애플리케이션이 할당한 ㅁ








### 객체와 배열

**Destructuring**

객체에안에 있는 필드 값을 원하는 변수에 대입 할 수 있다.  

```js
const sandwich={
bread :'더치 크런치',
meat:'참치',
cheese: '스위스',
topping:['상추','토마토','스위트어니언']
}
let {bread, meat} = sandwich;

console.log(bread,meat) //더치크런치 참지
```
위 코드는 객체를 분해하여 필드를 같은 이름의 변수에 넣어준다. 
**두변수의 값은 객체에 있는 필드값으로 초기화되지만, 두변수의 값을 재 할당해도 원래의 필드값은 변경되지 않는다.**

객체를 분해하여 함수의 인자로 넘길수도 있다. 

```js
const userName = (regularName) =>{
  console.log(` 유저 이름은! ${regularName.firstName}`)
}

let regularName ={
  firstName ='은경'
  lastName='잉'
}
userName(regularName); // 유저이름은! 은경

```

 객체 필드에 접근하기 위해 .과 필드명을 사용하는 대신에 객체에서 필요한 값을 구조분해로 가져올수 있다
 
 ```js
const userName = ({firstName}) =>{
  console.log(` 유저 이름은! ${regularName.firstName}`)
}

let regularName ={
  firstName ='은경'
  lastName='잉'
}
userName(regularName); // 유저이름은! 은경

```

배열의 구조 분해하기
>배열을 구조분해해서 값을 뽑아낼수도 있다. 

```js
const [pet1,pet2,pet3] = ['심바','모모','나나']

console.log(pet1) //'심바'
```


**객체 리터럴 개선**

>구조분해의 반대되는 개념이라고 할수 있다. 객체 리터럴개선을 사용하면 현재 영역에 변수를 객체의 필드로 묶을수 있다.


```js

const name = '은경';
const age = 33;

const userInfo = {name, age}

console.log(userInfo);// {name :'은경', age: 33}

```

**스프레드 연산자**

1. 스프레드 연산자를 사용해 배열의 내용을 조합할 수 있다. 예를 들어 두배열이 있다면 두 배열의 모두 들어간 새로운 배열을 만들수 있다.

```js
let array = [1,2,3];
let array02 = [4,5,6];
let newArray =[...array,...array02];

console.log(newArray) // [1,2,3,4,5,6]
```






## React

## TypeScript

## Task
